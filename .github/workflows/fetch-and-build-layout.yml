name: Fetch and build layout

on:
  workflow_dispatch:
    inputs:
      layout_id:
        description: "Layout id available in URL https://configure.zsa.io/voyager/layouts/[ID_IS_HERE]/latest"
        required: true
        default: "3aMQz"
      layout_geometry:
        description: "Keyboard type"
        type: choice
        options:
          - voyager
          - moonlander/reva
          - moonlander/revb
          - ergodox_ez
          - ergodox_ez/m32u4/glow
          - ergodox_ez/m32u4/shine
          - ergodox_ez/stm32
          - ergodox_ez/stm32/glow
          - ergodox_ez/stm32/shine
          - planck_ez
          - planck_ez/glow
        default: moonlander/reva

permissions:
  contents: write

jobs:
  fetch-and-build-layout:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download layout source
        id: download-layout-source
        run: |
          response=$(curl --location 'https://oryx.zsa.io/graphql' --header 'Content-Type: application/json' --data '{"query":"query getLayout($hashId: String!, $revisionId: String!, $geometry: String) {layout(hashId: $hashId, geometry: $geometry, revisionId: $revisionId) {  revision { hashId, qmkVersion, title }}}","variables":{"hashId":"${{ github.event.inputs.layout_id }}","geometry":"${{ github.event.inputs.layout_geometry }}","revisionId":"latest"}}')
          
          echo "GraphQL Response: $response"
          
          json_data=$(echo "$response" | jq '.data.layout.revision | [.hashId, .qmkVersion, .title]')
          hash_id=$(echo "${json_data}" | jq -r '.[0]')
          firmware_version=$(printf "%.0f" $(echo "${json_data}" | jq -r '.[1]'))
          change_description=$(echo "${json_data}" | jq -r '.[2]')
          
          if [[ "$hash_id" == "null" || -z "$hash_id" ]]; then
            echo "Error: Could not retrieve layout hash."
            exit 1
          fi
          
          if [[ -z "${change_description}" || "${change_description}" == "null" ]]; then
            change_description="latest layout modification made with Oryx"
          fi
          
          echo "Resolved Oryx latest revision: hash_id=${hash_id}, layout_id=${{ github.event.inputs.layout_id }}, geometry=${{ github.event.inputs.layout_geometry }}"
          echo "Downloading source for hash: $hash_id"
          curl -L "https://oryx.zsa.io/source/${hash_id}" -o source.zip
          
          # Verify zip
          if ! unzip -t source.zip > /dev/null 2>&1; then
            echo "Error: Invalid zip."
            exit 1
          fi
          
          echo firmware_version=${firmware_version} >> "$GITHUB_OUTPUT"
          echo change_description=${change_description} >> "$GITHUB_OUTPUT"
          echo hash_id=${hash_id} >> "$GITHUB_OUTPUT"

      - name: Unzip the source file
        run: |
          # Unzip to a temporary directory 'oryx_source' instead of directly to layout ID
          unzip -oj source.zip '*_source/*' -d oryx_source
          rm source.zip

      - name: Verify downloaded Oryx source before patch
        id: prepatch-check
        run: |
          set -euo pipefail

          echo "Verifying source for layout_id=${{ github.event.inputs.layout_id }} geometry=${{ github.event.inputs.layout_geometry }} hash_id=${{ steps.download-layout-source.outputs.hash_id }}"

          test -f oryx_source/keymap.c
          F24_COUNT=$( (grep -o "KC_F24" oryx_source/keymap.c || true) | wc -l | tr -d ' ' )
          echo "KC_F24 occurrences before patch: ${F24_COUNT}"

          if [ "${F24_COUNT}" -lt 1 ]; then
            echo "KC_F24 not present in downloaded keymap. Skipping strict FN24 replacement checks for this run."
            echo "requires_fn24_patch=false" >> "$GITHUB_OUTPUT"
          else
            echo "requires_fn24_patch=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Inject Custom Code (The Clever Bit)
        run: |
          set -euo pipefail

          # Copy custom code to the source directory
          cp custom_qmk/custom_code.c oryx_source/
          
          # Run python patch script
          python3 scripts/patch_keymap.py oryx_source custom_qmk/custom_code.c
          
          # Replace repo snapshot with freshly downloaded+patched files.
          # Important: if layout folder already exists, `mv oryx_source <layout_id>` would
          # nest the directory and leave stale files in place.
          LAYOUT_ID="${{ github.event.inputs.layout_id }}"
          rm -rf "${LAYOUT_ID}"
          mv oryx_source "${LAYOUT_ID}"

      - name: Verify patched keymap invariants
        run: |
          set -euo pipefail

          LAYOUT_ID="${{ github.event.inputs.layout_id }}"
          KEYMAP_PATH="${LAYOUT_ID}/keymap.c"
          test -f "${KEYMAP_PATH}"

          FN24_PATCH_MARKERS=$( (grep -o "ORYX_FN24_NUMDOT_SPACE_PATCH" "${KEYMAP_PATH}" || true) | wc -l | tr -d ' ' )
          F24_AFTER=$( (grep -o "KC_F24" "${KEYMAP_PATH}" || true) | wc -l | tr -d ' ' )
          echo "FN24 patch marker occurrences after patch: ${FN24_PATCH_MARKERS}"
          echo "KC_F24 occurrences after patch: ${F24_AFTER}"

          REQUIRE_FN24_PATCH="${{ steps.prepatch-check.outputs.requires_fn24_patch }}"
          echo "requires_fn24_patch=${REQUIRE_FN24_PATCH}"

          if [ "${REQUIRE_FN24_PATCH}" = "true" ]; then
            if [ "${FN24_PATCH_MARKERS}" -lt 1 ]; then
              echo "ERROR: FN24 replacement marker not found after patch; replacement did not apply."
              exit 1
            fi

            if [ "${F24_AFTER}" -gt 0 ]; then
              echo "ERROR: KC_F24 still present after patch; expected replacement did not complete."
              exit 1
            fi
          else
            echo "Skipping strict FN24 post-patch assertions because KC_F24 was absent in downloaded source."
          fi


      - name: Update QMK firmware submodule
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Clone qmk_firmware if not present
          if [ ! -d "qmk_firmware" ] || [ -z "$(ls -A qmk_firmware)" ]; then
             rm -rf qmk_firmware
             git clone --depth 1 https://github.com/zsa/qmk_firmware.git qmk_firmware
          fi
          cd qmk_firmware
          git fetch --all --tags
          FIRMWARE_BRANCH="firmware${{ steps.download-layout-source.outputs.firmware_version }}"
          if git show-ref --verify --quiet refs/remotes/origin/$FIRMWARE_BRANCH; then
            git checkout -B $FIRMWARE_BRANCH origin/$FIRMWARE_BRANCH
          else
            echo "Warning: Firmware branch $FIRMWARE_BRANCH not found, defaulting to master"
            git checkout master
          fi
          git submodule update --init --recursive

      - name: Build qmk docker image
        run: docker build -t qmk .

      - name: Build the layout
        id: build-layout
        run: |
          set -euo pipefail

          if [ "${{ steps.download-layout-source.outputs.firmware_version }}" -ge 24 ]; then
            keyboard_directory="qmk_firmware/keyboards/zsa"
            make_prefix="zsa/"
          else
            keyboard_directory="qmk_firmware/keyboards"
            make_prefix=""
          fi
          
          # Copy patched layout files to the qmk folder
          rm -rf ${keyboard_directory}/${{ github.event.inputs.layout_geometry }}/keymaps/${{ github.event.inputs.layout_id }}
          mkdir -p ${keyboard_directory}/${{ github.event.inputs.layout_geometry }}/keymaps && cp -r ${{ github.event.inputs.layout_id }} "$_"
          
          docker run -v $(pwd)/qmk_firmware:/root --rm qmk /bin/sh -c "
            make ${make_prefix}${{ github.event.inputs.layout_geometry }}:${{ github.event.inputs.layout_id }}
          "
          
          layout_id="${{ github.event.inputs.layout_id }}"
          normalized_layout_geometry="$(echo "${{ github.event.inputs.layout_geometry }}" | sed 's/\//_/g')"
          bin_candidate="$(find ./qmk_firmware -maxdepth 1 -type f -name "*${normalized_layout_geometry}*${layout_id}*.bin" | head -n 1 || true)"
          hex_candidate="$(find ./qmk_firmware -maxdepth 1 -type f -name "*${normalized_layout_geometry}*${layout_id}*.hex" | head -n 1 || true)"

          if [ -n "${bin_candidate}" ]; then
            built_firmware_file="${bin_candidate}"
          elif [ -n "${hex_candidate}" ]; then
            built_firmware_file="${hex_candidate}"
          else
            echo "ERROR: Could not find built firmware for ${normalized_layout_geometry}:${layout_id}."
            echo "Available top-level firmware candidates:"
            find ./qmk_firmware -maxdepth 1 -type f -name "*${normalized_layout_geometry}*" || true
            exit 1
          fi

          if [ ! -s "${built_firmware_file}" ]; then
            echo "ERROR: Built firmware file is missing or empty: ${built_firmware_file}"
            exit 1
          fi

          if [[ "${{ github.event.inputs.layout_geometry }}" == moonlander/* ]] && [[ "${built_firmware_file}" != *.bin ]]; then
            echo "ERROR: Moonlander build should produce .bin, but got: ${built_firmware_file}"
            exit 1
          fi

          echo "Built firmware file: ${built_firmware_file}"
          ls -lh "${built_firmware_file}"
          file "${built_firmware_file}" || true

          echo built_layout_file="${built_firmware_file}" >> "$GITHUB_OUTPUT"
          echo normalized_layout_geometry=${normalized_layout_geometry} >> "$GITHUB_OUTPUT"

      - name: Upload layout
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build-layout.outputs.normalized_layout_geometry }}_${{ github.event.inputs.layout_id }}
          path: ${{ steps.build-layout.outputs.built_layout_file }}

      - name: Publish firmware release asset
        uses: softprops/action-gh-release@v2
        with:
          tag_name: firmware-${{ steps.build-layout.outputs.normalized_layout_geometry }}-${{ github.event.inputs.layout_id }}-${{ steps.download-layout-source.outputs.hash_id }}
          name: Firmware ${{ steps.build-layout.outputs.normalized_layout_geometry }} ${{ github.event.inputs.layout_id }} @ ${{ steps.download-layout-source.outputs.hash_id }}
          body: |
            Built from Oryx layout `${{ github.event.inputs.layout_id }}` (`${{ github.event.inputs.layout_geometry }}`)
            Oryx revision hash: `${{ steps.download-layout-source.outputs.hash_id }}`
            Source change description: `${{ steps.download-layout-source.outputs.change_description }}`
          files: ${{ steps.build-layout.outputs.built_layout_file }}
          fail_on_unmatched_files: true
          overwrite_files: true

      - name: Commit synced layout folder to repository branch
        if: ${{ success() }}
        run: |
          set -euo pipefail

          BRANCH="${GITHUB_REF_NAME:-main}"
          LAYOUT_ID="${{ github.event.inputs.layout_id }}"
          MSG="${{ steps.download-layout-source.outputs.change_description }}"
          HASH_ID="${{ steps.download-layout-source.outputs.hash_id }}"
          GEOMETRY="${{ github.event.inputs.layout_geometry }}"

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Do NOT checkout/reset here; we want to keep the freshly generated layout files
          # from this run in the current workspace.

          # Stage only the synced layout directory
          git add "${LAYOUT_ID}"

          if git diff --cached --quiet; then
            echo "No layout changes to commit for ${LAYOUT_ID}."
            exit 0
          fi

          git commit -m "${MSG:-Sync Oryx layout source} [oryx:${HASH_ID:-unknown} geom:${GEOMETRY}]"
          git push origin "HEAD:${BRANCH}"

          echo "Git status for ${LAYOUT_ID} after push:"
          git status --short -- "${LAYOUT_ID}"

